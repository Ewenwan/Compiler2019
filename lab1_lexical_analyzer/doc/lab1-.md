# lab1

## 实验设计

根据 CMINUS 的语法，标识符和数字如下定义：
```
ID=letter letter*
NUM=digit digit*
letter = a|...|z|A|...|Z 
digit = 0|...|9
```

故正则表达式可以写成

```
ID=[a-zA-Z]+
NUM=[0-9]+
```

由于字母`letter`一定会被识别为标识符，所以不会出现在结果中（fjw 同学和助教有提到）。

专有符号和关键字匹配本身即可，不需要特别的表达式。

注释的匹配使用的是

```
"/*"([^\*]|(\*)[^\/])*"*/"
```

在匹配注释上花了一些时间，过程可见遇到的问题及解决方案。

关于`lines`的处理：遇到换行`\n`即加一。

关于`pos_start`和`pos_end`的处理：每次匹配之前（除 BLANK 和 EOL）`pos_start = pos_end;`，匹配结束之后`pos_end = pos_start + strlen(yytext);`。如果遇到BLANK 或 EOL 则做对应的简单处理（将`pos_end`相应移动，在下一次匹配时`pos_start = pos_end;`之后`pos_start`也做了相应移动）即可。

## 遇到的问题及解决方案

在匹配注释方面遇到了一些问题，开始时使用
```lex
"/*"(.|\n)*"*/"
```
但是发现不相邻的两个注释会被判定为一个注释（因为正则的匹配是贪心的（fjw 同学和老师均有提到）），两个注释之间的代码内容也会被识别为注释，故需重新编写正则表达式。

Google 之后找到了参考文献[1]中的写法，然后又根据他的思路化简了一下，决定使用
```lex
"/*"([^\*]|(\*)[^\/])*"*/"
```
匹配注释。

`/*`和`*/`分别是注释的最前面和最后面。

对于中间的字符，要么不出现`*`，要么在`*`之后不能出现`/`（否则连在一起就可能是注释的结尾），以上规则的闭包就是中间字符的规则。这样既可以匹配单行的注释，也可以匹配多行的注释。

## 时间统计

因之前在操作系统课程实验中使用过`lex`，所以上手相对较快。了解 CMINUS 的语法和构建好输入输出过程用时 1 小时左右，构建分词过程、设计数据以及完成实验报告共计用时 2 小时左右（用了较多时间在匹配注释上）。本次实验共计用时约 3 小时。 

## 参考文献

[1. Find comment in C source code](http://blog.ostermiller.org/find-comment)